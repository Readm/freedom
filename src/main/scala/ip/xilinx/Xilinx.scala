package sifive.freedom.ip.xilinx

import Chisel._
import chisel3.core.{Input, Output, attach}
import chisel3.experimental.{Analog}

import sifive.blocks.devices.gpio.{GPIOPin}

//========================================================================
// This file contains common devices used by our Xilinx FPGA flows and some
// BlackBox modules used in the Xilinx FPGA flows
//========================================================================

//-------------------------------------------------------------------------
// IBUFDS
//-------------------------------------------------------------------------
//IP : xilinx unisim IBUFDS. SelectIO Differential Signaling Input
// Buffer unparameterized

class IBUFDS extends BlackBox {
  val io = new Bundle {
    val O         = Bool(OUTPUT)
    val I         = Bool(INPUT)
    val IB        = Bool(INPUT)
  }
}

//-------------------------------------------------------------------------
// IBUFG
//-------------------------------------------------------------------------
/** IBUFG -- Clock Input Buffer */

class IBUFG extends BlackBox {
  val io = new Bundle {
    val O = Output(Clock())
    val I = Input(Clock())
  }
}

object IBUFG {
  def apply (pin: Clock): Clock = {
    val pad = Module (new IBUFG())
    pad.io.I := pin
    pad.io.O
  }
}

//-------------------------------------------------------------------------
// IOBUF
//-------------------------------------------------------------------------
/** IOBUF -- Bidirectional IO Buffer. */

class IOBUF extends BlackBox {
  val io = new Bundle {
    val O  = Output(Bool())
    val IO = Analog(1.W)
    val I  = Input(Bool())
    val T  = Input(Bool())
  }
}

object IOBUF {
  def apply (pin: Analog, ctrl: GPIOPin): Bool = {
    val pad = Module(new IOBUF())
    pad.io.I    := ctrl.o.oval
    pad.io.T    := ~ctrl.o.oe
    ctrl.i.ival := pad.io.O & ctrl.o.ie
    attach(pad.io.IO, pin)
    pad.io.O & ctrl.o.ie
  }

  // Creates an output IOBUF
  def apply (pin: Analog, in: Bool): Unit = {
    val pad = Module(new IOBUF())
    pad.io.I := in
    pad.io.T := false.B
    attach(pad.io.IO, pin)
  }

  // Creates an input IOBUF
  def apply (pin: Analog): Bool = {
    val pad = Module(new IOBUF())
    pad.io.I := false.B
    pad.io.T := true.B
    attach(pad.io.IO, pin)
    pad.io.O
  }
}

//-------------------------------------------------------------------------
// PULLUP
//-------------------------------------------------------------------------
/** PULLUP : can be applied to Input to add a Pullup. */

class PULLUP extends BlackBox {
  val io = new Bundle {
    val O = Analog(1.W)
  }
}

object PULLUP {
  def apply (pin: Analog): Unit = {
    val pullup = Module(new PULLUP())
    attach(pullup.io.O, pin)
  }
}

//-------------------------------------------------------------------------
// mmcm
//-------------------------------------------------------------------------
/** mmcm: This is generated by the Xilinx IP Generation Scripts */

class mmcm extends BlackBox {
  val io = new Bundle {
    val clk_in1  = Input(Clock())
    val clk_out1 = Output(Clock())
    val clk_out2 = Output(Clock())
    val clk_out3 = Output(Clock())
    val resetn   = Input(Bool())
    val locked   = Output(Bool())
  }
}

//-------------------------------------------------------------------------
// reset_sys
//-------------------------------------------------------------------------
/** reset_sys: This is generated by the Xilinx IP Generation Scripts */

class reset_sys extends BlackBox {
  val io = new Bundle {
    val slowest_sync_clk     = Input(Clock())
    val ext_reset_in         = Input(Bool())
    val aux_reset_in         = Input(Bool())
    val mb_debug_sys_rst     = Input(Bool())
    val dcm_locked           = Input(Bool())
    val mb_reset             = Output(Bool())
    val bus_struct_reset     = Output(Bool())
    val peripheral_reset     = Output(Bool())
    val interconnect_aresetn = Output(Bool())
    val peripheral_aresetn   = Output(Bool())
  }
}

//-------------------------------------------------------------------------
// PowerOnResetFPGAOnly
//-------------------------------------------------------------------------
/** PowerOnResetFPGAOnly -- this generates a power_on_reset signal using
  * initial blocks.  It is synthesizable on FPGA flows only.
  */

// This is a FPGA-Only construct, which uses
// 'initial' constructions
class PowerOnResetFPGAOnly extends BlackBox {
  val io = new Bundle {
    val clock = Input(Clock())
    val power_on_reset = Output(Bool())
  }
}

object PowerOnResetFPGAOnly {
  def apply (clk: Clock): Bool = {
    val por = Module(new PowerOnResetFPGAOnly())
    por.io.clock := clk
    por.io.power_on_reset
  }
}

//-------------------------------------------------------------------------
// ClockDivider256
//-------------------------------------------------------------------------
// Divides an input clock by 256 -- used in E300ArtyDevKitFPGATop

class ClockDivider256 extends BlackBox {
  val io = new Bundle {
    val clk     = Input(Clock())
    val reset   = Input(Bool())
    val clk_out = Output(Bool())
  }
}

object ClockDivider256 {
  def apply(clk: Clock, reset: Bool): Bool = {
    val m = Module(new ClockDivider256())
    m.io.clk   := clk
    m.io.reset := reset
    m.io.clk_out
  }
}

//-------------------------------------------------------------------------
// vc707clk_wiz_sync
//-------------------------------------------------------------------------
//IP : xilinx mmcm with "NO_BUFFER" input clock

class vc707clk_wiz_sync extends BlackBox {
  val io = new Bundle {
    val clk_in1   = Bool(INPUT)
    val clk_out1  = Clock(OUTPUT)
    val clk_out2  = Clock(OUTPUT)
    val clk_out3  = Clock(OUTPUT)
    val clk_out4  = Clock(OUTPUT)
    val clk_out5  = Clock(OUTPUT)
    val clk_out6  = Clock(OUTPUT)
    val clk_out7  = Clock(OUTPUT)
    val reset     = Bool(INPUT)
    val locked    = Bool(OUTPUT)
  }
}

//-------------------------------------------------------------------------
// vc707reset
//-------------------------------------------------------------------------

class vc707reset() extends BlackBox
{
  val io = new Bundle{
    val areset = Bool(INPUT)
    val clock1 = Clock(INPUT)
    val reset1 = Bool(OUTPUT)
    val clock2 = Clock(INPUT)
    val reset2 = Bool(OUTPUT)
    val clock3 = Clock(INPUT)
    val reset3 = Bool(OUTPUT)
    val clock4 = Clock(INPUT)
    val reset4 = Bool(OUTPUT)
  }
}
